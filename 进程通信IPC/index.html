<!DOCTYPE html>
<html lang="en">

<!-- layout.ejs-->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="This is the site where Steven post his thoughts, ideas and feelings">
    <meta name="author" content="Huan Li">
    <meta name="keyword" content="Computer Science, Travel Notes, Ideas and Thoughts">
    <link rel="canonical" href="https://longaspire.github.io/blog/blog/进程通信IPC/">
    <link rel="shortcut icon" href="/blog/img/rockrms.png">
    <link rel="alternate" type="application/atom+xml" title="Little Stone" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>

    <title>
        
        进程通信IPC｜Little Stone - Huan Li&#39;s Blog
        
    </title>

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

    <link rel="stylesheet" href="/blog/css/main.css">

    
      <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
      <link rel="stylesheet" href="/blog/css/highlight.css">
    

    

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


    
      <meta name="google-site-verification" content="Q9_p57DiEwLUAkG7RSWhWgytI3usFEsDzkR3UMn-RW8" />
    

    

    


    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-118875263-1', 'auto');
    ga('send', 'pageview');
</script>





    <script async defer src="https://buttons.github.io/buttons.js"></script>

</head>

<style>
    header.intro-header {
        background-image: url('')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<header>
  <nav class="navbar navbar-default header-navbar" id="nav-top" data-ispost = "true" data-istags="false" data-ishome = "false" >
    <div class="container-fluid">
      <div class="navbar-header page-scroll">
        <button type="button" class="navbar-toggle" data-toggle="collapse" aria-expanded="false"  data-target="#website_navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <span class="navbar-brand animated pulse">
          <a class="brand-logo" href="/blog/">
                <img src="/blog/img/banner.png?h=350&amp;auto=compress&amp;cs=tinysrgb" />
          </a>
        </span>
      </div>

      <div class="collapse navbar-collapse" id="website_navbar">
          <ul class="nav navbar-nav navbar-right">
              
                <li>
                  <a href="/blog/">home</a>
                </li>
              
                <li>
                  <a href="/blog/the-milestone-2018/">about</a>
                </li>
              
                <li>
                  <a href="/blog/categories/">categories</a>
                </li>
              
                <li>
                  <a href="/blog/archives/">archives</a>
                </li>
              
                <li>
                  <a href="/blog/tags/">tags</a>
                </li>
              
          </ul>
      </div>
  </nav>


  
    <style>
       .intro-header {
          background-image: url('/blog/img/firenze.png?h=350&amp;auto=compress&amp;cs=tinysrgb');
      }
    </style>

    <div class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                    <div class="site-heading">
                        <h1>进程通信IPC</h1>
                        
                        
                          <span class="meta">
                               <span class="meta-item">Author: Huan Li</span>
                               <span class="meta-item">Date: Dec 13, 2014</span>
                               
                                 <span class="meta-item">Updated On: May 8, 2018</span>
                               
                          </span>
                          <div class="tags text-center">
                              Categories: 
                              <a class="tag" href="/blog/categories/#OS"
                                 title="OS">OS</a>
                              
                          </div>
                          <div class="tags text-center">
                              Tags: 
                              <a class="tag" href="/blog/tags/#Linux"
                                 title="Linux">Linux</a>
                              
                              <a class="tag" href="/blog/tags/#IPC"
                                 title="IPC">IPC</a>
                              
                              <a class="tag" href="/blog/tags/#os"
                                 title="os">os</a>
                              
                              <a class="tag" href="/blog/tags/#进程"
                                 title="进程">进程</a>
                              
                              <a class="tag" href="/blog/tags/#通信"
                                 title="通信">通信</a>
                              
                          </div>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
  
</header>


<!-- Main Content -->
<!-- post.ejs -->
<article>
    <div class="container">
      <div class="col-lg-8 col-lg-offset-1 col-sm-9">
          
          
          <p>&lt; 本文转载自引用[1] &gt;</p>
<blockquote>
<p>进程间通信 (IPC, InterProcess Communication) 是指在不同进程之间传播或交换信息。</p>
</blockquote>
<p>IPC的方式通常由管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中Socket和Streams支持在不同主机上进行IPC。</p>
<h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h3><p>_管道_，通常指无名管道，是UNIX系统IPC中最古老的形式。</p>
<h4 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h4><ol>
<li><strong>半双工</strong>（数据只能在一个方向上流动），读端和写端是固定的；</li>
<li>只能用于具有<strong>亲缘关系</strong>的进程之间的通信（也就是父子进程或者兄弟进程之间）；</li>
<li>它可看成一种特殊的文件，对于它的读写可以使用普通的read、write等函数。但其不是普通的文件，也不属于任何文件系统，并且只能存在于<strong>内存</strong>之中。</li>
</ol>
<h4 id="1-2-原型"><a href="#1-2-原型" class="headerlink" title="1.2 原型"></a>1.2 原型</h4><pre lang="c" line="1">

#include<unistd.h>
int pipe(int fd[2]); // 返回值：若成功返回0，失败返回-1

</unistd.h></pre>

<p>当一个管道建立时，会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开，如下图</p>
<p><img src="http://img.blog.csdn.net/20150419222058628?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="pipe例子"><span class="image-caption-center">pipe例子</span></p>
<p>要关闭管道只需要将这两个文件描述符关闭即可。</p>
<h4 id="1-3-例子"><a href="#1-3-例子" class="headerlink" title="1.3 例子"></a>1.3 例子</h4><p>单个进程中的管道几乎没有任何用处。通常调用pipe的进程接着调用fork，这样就创建了父进程与子进程之间的IPC通道，如下图：</p>
<p><img src="http://img.blog.csdn.net/20150419223853807?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="pipe+fork"><span class="image-caption-center">pipe+fork</span></p>
<p>如果要数据流从父进程流向子进程，则关闭父进程的读端 (<code>fd[0]</code>) 与子进程的写端 (<code>fd[0]</code>)；反之，这可以使得数据流从子进程流向父进程。</p>
<pre lang="c" line="1">

#include<stdio.h>
#include<unistd.h>

int main(){
    int fd[2];  // 两个文件描述符
    pid_t pid;
    char buff[20];

    if(pipe(fd) < 0)  // 创建管道
        printf("Create Pipe Error!\n");

    if((pid = fork()) < 0)  // 创建子进程
        printf("Fork Error!\n");
    else if(pid > 0)  // 父进程
    {
        close(fd[0]); // 关闭读端
        write(fd[1], "hello world\n", 12);
    }
    else
    {
        close(fd[1]); // 关闭写端
        read(fd[0], buff, 20);
        printf("%s", buff);
    }

    return 0;
}

</unistd.h></stdio.h></pre>

<h3 id="2-FIFO"><a href="#2-FIFO" class="headerlink" title="2. FIFO"></a>2. FIFO</h3><p><em>FIFO</em>，也称为命名管道，它是一种文件类型。</p>
<h4 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h4><ol>
<li>FIFO可以在无关的进程之间交换数据，与无名管道不同；</li>
<li>FIFO有路径名与之相关联，是一种特殊设备文件形式存在于文件系统中。</li>
</ol>
<h4 id="2-2-原型"><a href="#2-2-原型" class="headerlink" title="2.2 原型"></a>2.2 原型</h4><pre lang="c" line="1">

#include<sys stat.h="">
// 返回值： 成功返回0，出错返回-1
int mkfifo(const char *pathname, mode_t mode)

</sys></pre>

<p>其中的mode参数与<code>open</code>函数中的mode相同，一旦创建了一个FIFO，就可以用一般的文件I/O函数操作它。</p>
<p>当open一个FIFO是，是否设置非阻塞标志 (<code>O_NONBLOCK</code>)的区别：</p>
<ol>
<li>若没有指定<code>O_NONBLOCK</code> (默认)，只读open要阻塞到某个其他进程为写而打开此FIFO。类似的，只写open要阻塞到某个其他进程为读而打开它；</li>
<li>若指定了<code>O_NONBLOCK</code>，则只读open立即返回。而只写open将出错返回-1如果没有进程已经为读而打开该FIFO，其errno为ENXIO。</li>
</ol>
<h4 id="2-3-例子"><a href="#2-3-例子" class="headerlink" title="2.3 例子"></a>2.3 例子</h4><p>FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”，下面给出一个例子：</p>
<p><code>write_fifo.c</code></p>
<pre lang="c" line="1">

#include<stdio.h>
#include<stdlib.h>   // exit
#include<fcntl.h>    // O_WRONLY
#include<sys stat.h="">
#include<time.h>     // time

int main()
{
    int fd;
    int n, i;
    char buf[1024];
    time_t tp;

    printf("I am %d process.\n", getpid()); // 说明进程ID

    if((fd = open("fifo1", O_WRONLY)) < 0) // 以写打开一个FIFO 
    {
        perror("Open FIFO Failed");
        exit(1);
    }

    for(i = 0; i < 10; ++i){
        time(&tp);
        n=sprintf(buf,"Process %d's time is %s",getpid(),ctime(&tp));
        printf("Send message: %s", buf); // 打印
        if(write(fd, buf, n+1) < 0)  // 写入到FIFO中
        {
            perror("Write FIFO Failed");
            close(fd);
            exit(1);
        }
        sleep(1);  // 休眠1秒
    }

    close(fd);  // 关闭FIFO文件
    return 0;
}

</time.h></sys></fcntl.h></stdlib.h></stdio.h></pre>

<p><code>read_fifo.c</code></p>
<pre lang="c" line="1">

#include<stdio.h>
#include<stdlib.h>
#include<errno.h>
#include<fcntl.h>
#include<sys stat.h="">

int main()
{
    int fd;
    int len;
    char buf[1024];

    if(mkfifo("fifo1", 0666) < 0 && errno!=EEXIST) // 创建FIFO管道
        perror("Create FIFO Failed");

    if((fd = open("fifo1", O_RDONLY)) < 0)  // 以读打开FIFO
    {
        perror("Open FIFO Failed");
        exit(1);
    }

    while((len = read(fd, buf, 1024)) > 0) // 读取FIFO管道
        printf("Read message: %s", buf);

    close(fd);  // 关闭FIFO文件
    return 0;
}

</sys></fcntl.h></errno.h></stdlib.h></stdio.h></pre>

<p>可以在两个终端里用 gcc分别编译运行上面两个文件，查看结果。</p>
<p>上述例子可以扩展成 客户进程-服务器进程 通信的实例，<code>write_fifo</code>的作用类似于客户端，可以打开多个客户端向一个服务器发送请求信息，<code>read_fifo</code>类似于服务器，实时监控着FIFO的读端，当有数据时，读取并进行处理，但是有一个关键问题是，每一个客户端必须预先知道服务器提供的FIFO接口，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150420131002360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzb25nbGlzb25nbGlzb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="fifo"><span class="image-caption-center">fifo</span></p>
<h3 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3. 消息队列"></a>3. 消息队列</h3><p><em>消息队列</em>，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</p>
<h4 id="3-1-特点"><a href="#3-1-特点" class="headerlink" title="3.1 特点"></a>3.1 特点</h4><ol>
<li>消息队列是面向记录的，其中的消息具有特定的格式及特定的优先级；</li>
<li>消息队列独立于发送与接收的进程。进程终止时，消息队列及其内容不会被删除；</li>
<li>消息队列可以实现消息的随机查询，消息不一定要按照先进先出的次序读取，也可以按照消息的类型读取。</li>
</ol>
<h4 id="3-2-原型"><a href="#3-2-原型" class="headerlink" title="3.2 原型"></a>3.2 原型</h4><pre lang="c" line="1">

#include<sys msg.h="">

// 创建或打开消息队列：成功返回队列ID，失败返回-1
int msgget(key_t key, int flag);

// 添加消息：成功返回0，失败返回-1
int msgsnd(int msqid, const void *ptr, size_t size, int flag);

// 读取消息：成功返回消息数据的长度，失败返回-1
int msgrcv(int msqid, void *ptr, size_t size, long type, int flag);

// 控制消息队列：成功返回0，失败返回-1
int msgctl(int msqid, int cmd, struct msqid_ds *buf);

</sys></pre>

<p>在以下两种情况下，<code>msgget</code>将创建一个新的消息队列：<br>1. 如果没有与键值key相对应的消息队列，并且flag中包含了<code>IPC_CREAT</code>标志位；<br>2. key参数为<code>IPC_PRIVATE</code>。</p>
<p>函数<code>msgrcv</code>在读取消息队列时，type参数有以下几种情况：<br>1. <code>type == 0</code>，返回队列中的第一个消息；<br>2. <code>type &amp;gt; 0</code>，返回队列中消息类型为type的第一个消息；<br>3. <code>type &amp;lt; 0</code>，返回队列中消息类型值小于或者等于type绝对值的消息，如果有多个，则取类型值最小的消息。</p>
<p>可看出，type值非0时用于以非先进先出次序读取消息，也可以把type看成优先级的权值。</p>
<h4 id="3-3-例子"><a href="#3-3-例子" class="headerlink" title="3.3 例子"></a>3.3 例子</h4><p>下面是一个使用消息队列进行IPC的例子，服务端程序一直在等待特定类型的消息，当收到该类型的消息后，发送另一种特定类型的消息作为反馈，客户端读取该反馈并打印出来。</p>
<p><code>msg_server.c</code></p>
<pre lang="c" line="1">

#include<stdio.h>
#include<stdlib.h>
#include<sys msg.h="">

// 用于创建一个唯一的key
#define MSG_FILE "/etc/passwd"

// 消息结构
struct msg_form {
    long mtype;
    char mtext[256];
};

int main()
{
    int msqid;
    key_t key;
    struct msg_form msg;

    // 获取key值
    if((key = ftok(MSG_FILE,'z')) < 0)
    {
        perror("ftok error");
        exit(1);
    }

    // 打印key值
    printf("Message Queue - Server key is: %d.\n", key);

    // 创建消息队列
    if ((msqid = msgget(key, IPC_CREAT|0777)) == -1)
    {
        perror("msgget error");
        exit(1);
    }

    // 打印消息队列ID及进程ID
    printf("My msqid is: %d.\n", msqid);
    printf("My pid is: %d.\n", getpid());

    // 循环读取消息
    for(;;) 
    {
        msgrcv(msqid, &msg, 256, 888, 0);// 返回类型为888的第一个消息
        printf("Server: receive msg.mtext is: %s.\n", msg.mtext);
        printf("Server: receive msg.mtype is: %d.\n", msg.mtype);

        msg.mtype = 999; // 客户端接收的消息类型
        sprintf(msg.mtext, "hello, I'm server %d", getpid());
        msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
    }
    return 0;
}

</sys></stdlib.h></stdio.h></pre>

<p><code>msg_client.c</code></p>
<pre lang="c" line="1">

#include<stdio.h>
#include<stdlib.h>
#include<sys msg.h="">

// 用于创建一个唯一的key
#define MSG_FILE "/etc/passwd"

// 消息结构
struct msg_form {
    long mtype;
    char mtext[256];
};

int main()
{
    int msqid;
    key_t key;
    struct msg_form msg;

    // 获取key值
    if ((key = ftok(MSG_FILE, 'z')) < 0) 
    {
        perror("ftok error");
        exit(1);
    }

    // 打印key值
    printf("Message Queue - Client key is: %d.\n", key);

    // 打开消息队列
    if ((msqid = msgget(key, IPC_CREAT|0777)) == -1) 
    {
        perror("msgget error");
        exit(1);
    }

    // 打印消息队列ID及进程ID
    printf("My msqid is: %d.\n", msqid);
    printf("My pid is: %d.\n", getpid());

    // 添加消息，类型为888
    msg.mtype = 888;
    sprintf(msg.mtext, "hello, I'm client %d", getpid());
    msgsnd(msqid, &msg, sizeof(msg.mtext), 0);

    // 读取类型为777的消息
    msgrcv(msqid, &msg, 256, 999, 0);
    printf("Client: receive msg.mtext is: %s.\n", msg.mtext);
    printf("Client: receive msg.mtype is: %d.\n", msg.mtype);
    return 0;
}

</sys></stdlib.h></stdio.h></pre>

<h3 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4. 信号量"></a>4. 信号量</h3><p><em>信号量</em> (semaphore) 与已经介绍过的IPC结构不同，是一个计数器。信号量用于实现进程间的互斥和同步，而不用于存储进程间的通信数据。</p>
<h4 id="4-1-特点"><a href="#4-1-特点" class="headerlink" title="4.1 特点"></a>4.1 特点</h4><ol>
<li>信号量用于进程间同步，若要在进程间传递数据需要结合<em>共享内存</em>；</li>
<li>信号量基于操作系统的PV操作[3]，程序对信号量的操作都是原子操作；</li>
<li>每次对信号量的PV操作不仅限于对信号量+1或者-1，可以加减任意正整数；</li>
<li>支持信号量组。</li>
</ol>
<h4 id="4-2-原型"><a href="#4-2-原型" class="headerlink" title="4.2 原型"></a>4.2 原型</h4><p>最简单的信号量只能取0和1的变量，这也是信号量最常见的一种形式，叫做<em>二值信号量</em> (Binary Semaphore)。而可以取多个正整数的信号量也被称为通用信号量。</p>
<p>Linux下的信号量函数是在通用的信号量数组上进行操作，而不是在一个单一的二值信号量上进行操作。</p>
<pre 1="" lang="c" line="">

#include<sys sem.h="">

// 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1
int semget(key_t key, int num_sems, int sem_flags);

// 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1
int semop(int semid, struct sembuf semoparray[], size_t numops);

// 控制信号量的相关信息
int semctl(int semid, int sem_num, int cmd, ...);

</sys></pre>

<p>当<code>semget</code>创建新的信号量集合时，必须指定集合中信号量的个数 (即<code>num_sems</code>)，通常为1；如果是引用一个现有的集合，则将<code>num_sems</code>指定为0。</p>
<p>在<code>semop</code>函数中，<code>sembuf</code>结构的定义如下：</p>
<pre lang="c" line="1">

struct sembuf
{
    short sem_num; // 信号量组中对应的序号，0~sem_nums-1
    short sem_op; // 信号量值在一次操作中的改变量
    short sem_flag; // IPC_NOWAIT, SEM_UNDO
}

</pre>

<p>其中<code>sem_op</code>是一次操作中的信号量的改变量：</p>
<ul>
<li>若<code>sem_op &amp;gt; 0</code>，表示进程释放相应的资源数，将 sem_op 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则换行它们。</li>
<li>若<code>sem_op &amp;lt; 0</code>，请求 sem_op 的绝对值的资源。</li>
<li>若<code>sem_op == 0</code>，进程阻塞直到信号量的相应值为0。</li>
</ul>
<h3 id="5-共享内存"><a href="#5-共享内存" class="headerlink" title="5. 共享内存"></a>5. 共享内存</h3><p><em>共享内存</em> (Shared Memory)，指两个或多个进程共享一个给定的存储区。</p>
<h4 id="5-1-特点"><a href="#5-1-特点" class="headerlink" title="5.1 特点"></a>5.1 特点</h4><ol>
<li>共享内存是最快的一种IPC，因为进程是直接对内存进行存取；</li>
<li>因为多个进程可以同时操作，所以需要进行同步；</li>
<li>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</li>
</ol>
<h4 id="5-2-原型"><a href="#5-2-原型" class="headerlink" title="5.2 原型"></a>5.2 原型</h4><pre lang="c" line="1">

#include<sys sem.h="">

// 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1
int shmget(key_t key, size_t size, int flag);

// 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1
void *shmat(int shm_id, const void *addr, int flag);

// 断开与共享内存的连接：成功返回0，失败返回-1
int shmdt(void addr*);

// 控制共享内存的相关信息：成功返回0，失败返回-1
int shmctl(int shm_id, int cmd, struct shmid_ds *buf);

</sys></pre>

<p>当用<code>shmget</code>函数创建一段共享内存时，必须指定其size；而如果引用一个已存在的共享内存，则将size指定为0。</p>
<p>当一段共享内存被创建以后，它并不能被任何进程访问。必须使用<code>shmat</code>函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。</p>
<p><code>shmat</code>函数是用来断开<code>shmat</code>建立的连接的。注意，并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已。</p>
<p><code>shmctl</code>函数可以对共享内存执行多种操作，根据参数cmd执行相应的操作。常见的是<code>IPC_RMID</code> (从系统中删除该共享内存)。</p>
<h4 id="5-3例子"><a href="#5-3例子" class="headerlink" title="5.3例子"></a>5.3例子</h4><p>下面这个例子，使用了【共享内存+信号量+消息队列】的组合来实现服务器进程与客户进程间的通信。</p>
<ul>
<li>共享内存用来传递数据；</li>
<li>信号量用来同步；</li>
<li>消息队列用来在客户端修改了共享内存后通知服务器读取。</li>
</ul>
<p><code>Server.c</code></p>
<pre lang="c" line="1">

#include<stdio.h>
#include<stdlib.h>
#include<sys shm.h="">  // shared memory
#include<sys sem.h="">  // semaphore
#include<sys msg.h="">  // message queue
#include<string.h>   // memcpy

// 消息队列结构
struct msg_form {
    long mtype;
    char mtext;
};

// 联合体，用于semctl初始化
union semun
{
    int              val; /*for SETVAL*/
    struct semid_ds *buf;
    unsigned short  *array;
};

// 初始化信号量
int init_sem(int sem_id, int value)
{
    union semun tmp;
    tmp.val = value;
    if(semctl(sem_id, 0, SETVAL, tmp) == -1)
    {
        perror("Init Semaphore Error");
        return -1;
    }
    return 0;
}

// P操作:
//  若信号量值为1，获取资源并将信号量值-1 
//  若信号量值为0，进程挂起等待
int sem_p(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0; /*序号*/
    sbuf.sem_op = -1; /*P操作*/
    sbuf.sem_flg = SEM_UNDO;

    if(semop(sem_id, &sbuf, 1) == -1)
    {
        perror("P operation Error");
        return -1;
    }
    return 0;
}

// V操作：
//  释放资源并将信号量值+1
//  如果有进程正在挂起等待，则唤醒它们
int sem_v(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0; /*序号*/
    sbuf.sem_op = 1;  /*V操作*/
    sbuf.sem_flg = SEM_UNDO;

    if(semop(sem_id, &sbuf, 1) == -1)
    {
        perror("V operation Error");
        return -1;
    }
    return 0;
}

// 删除信号量集
int del_sem(int sem_id)
{
    union semun tmp;
    if(semctl(sem_id, 0, IPC_RMID, tmp) == -1)
    {
        perror("Delete Semaphore Error");
        return -1;
    }
    return 0;
}

// 创建一个信号量集
int creat_sem(key_t key)
{
    int sem_id;
    if((sem_id = semget(key, 1, IPC_CREAT|0666)) == -1)
    {
        perror("semget error");
        exit(-1);
    }
    init_sem(sem_id, 1);  /*初值设为1资源未占用*/
    return sem_id;
}

int main()
{
    key_t key;
    int shmid, semid, msqid;
    char *shm;
    char data[] = "this is server";
    struct shmid_ds buf1;  /*用于删除共享内存*/
    struct msqid_ds buf2;  /*用于删除消息队列*/
    struct msg_form msg;  /*消息队列用于通知对方更新了共享内存*/

    // 获取key值
    if((key = ftok(".", 'z')) < 0)
    {
        perror("ftok error");
        exit(1);
    }

    // 创建共享内存
    if((shmid = shmget(key, 1024, IPC_CREAT|0666)) == -1)
    {
        perror("Create Shared Memory Error");
        exit(1);
    }

    // 连接共享内存
    shm = (char*)shmat(shmid, 0, 0);
    if((int)shm == -1)
    {
        perror("Attach Shared Memory Error");
        exit(1);
    }

    // 创建消息队列
    if ((msqid = msgget(key, IPC_CREAT|0777)) == -1)
    {
        perror("msgget error");
        exit(1);
    }

    // 创建信号量
    semid = creat_sem(key);

    // 读数据
    while(1)
    {
        msgrcv(msqid, &msg, 1, 888, 0); /*读取类型为888的消息*/
        if(msg.mtext == 'q')  /*quit - 跳出循环*/ 
            break;
        if(msg.mtext == 'r')  /*read - 读共享内存*/
        {
            sem_p(semid);
            printf("%s\n",shm);
            sem_v(semid);
        }
    }

    // 断开连接
    shmdt(shm);

    /*删除共享内存、消息队列、信号量*/
    shmctl(shmid, IPC_RMID, &buf1);
    msgctl(msqid, IPC_RMID, &buf2);
    del_sem(semid);
    return 0;
}

</string.h></sys></sys></sys></stdlib.h></stdio.h></pre>

<p><code>Client.c</code></p>
<pre lang="c" line="1">

#include<stdio.h>
#include<stdlib.h>
#include<sys shm.h="">  // shared memory
#include<sys sem.h="">  // semaphore
#include<sys msg.h="">  // message queue
#include<string.h>   // memcpy

// 消息队列结构
struct msg_form {
    long mtype;
    char mtext;
};

// 联合体，用于semctl初始化
union semun
{
    int              val; /*for SETVAL*/
    struct semid_ds *buf;
    unsigned short  *array;
};

// P操作:
//  若信号量值为1，获取资源并将信号量值-1 
//  若信号量值为0，进程挂起等待
int sem_p(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0; /*序号*/
    sbuf.sem_op = -1; /*P操作*/
    sbuf.sem_flg = SEM_UNDO;

    if(semop(sem_id, &sbuf, 1) == -1)
    {
        perror("P operation Error");
        return -1;
    }
    return 0;
}

// V操作：
//  释放资源并将信号量值+1
//  如果有进程正在挂起等待，则唤醒它们
int sem_v(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0; /*序号*/
    sbuf.sem_op = 1;  /*V操作*/
    sbuf.sem_flg = SEM_UNDO;

    if(semop(sem_id, &sbuf, 1) == -1)
    {
        perror("V operation Error");
        return -1;
    }
    return 0;
}

int main()
{
    key_t key;
    int shmid, semid, msqid;
    char *shm;
    struct msg_form msg;
    int flag = 1; /*while循环条件*/

    // 获取key值
    if((key = ftok(".", 'z')) < 0)
    {
        perror("ftok error");
        exit(1);
    }

    // 获取共享内存
    if((shmid = shmget(key, 1024, 0)) == -1)
    {
        perror("shmget error");
        exit(1);
    }

    // 连接共享内存
    shm = (char*)shmat(shmid, 0, 0);
    if((int)shm == -1)
    {
        perror("Attach Shared Memory Error");
        exit(1);
    }

    // 创建消息队列
    if ((msqid = msgget(key, 0)) == -1)
    {
        perror("msgget error");
        exit(1);
    }

    // 获取信号量
    if((semid = semget(key, 0, 0)) == -1)
    {
        perror("semget error");
        exit(1);
    }

    // 写数据
    printf("***************************************\n");
    printf("*                 IPC                 *\n");
    printf("*    Input r to send data to server.  *\n");
    printf("*    Input q to quit.                 *\n");
    printf("***************************************\n");

    while(flag)
    {
        char c;
        printf("Please input command: ");
        scanf("%c", &c);
        switch(c)
        {
            case 'r':
                printf("Data to send: ");
                sem_p(semid);  /*访问资源*/
                scanf("%s", shm);
                sem_v(semid);  /*释放资源*/
                /*清空标准输入缓冲区*/
                while((c=getchar())!='\n' && c!=EOF);
                msg.mtype = 888;  
                msg.mtext = 'r';  /*发送消息通知服务器读数据*/
                msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
                break;
            case 'q':
                msg.mtype = 888;
                msg.mtext = 'q';
                msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
                flag = 0;
                break;
            default:
                printf("Wrong input!\n");
                /*清空标准输入缓冲区*/
                while((c=getchar())!='\n' && c!=EOF);
        }
    }

    // 断开连接
    shmdt(shm);

    return 0;
}

</string.h></sys></sys></sys></stdlib.h></stdio.h></pre>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ol>
<li><a href="http://songlee24.github.io/2015/04/21/linux-IPC/" target="_blank" rel="noopener">http://songlee24.github.io/2015/04/21/linux-IPC/</a></li>
<li><a href="http://www.cnblogs.com/CheeseZH/p/5264465.html" target="_blank" rel="noopener">http://www.cnblogs.com/CheeseZH/p/5264465.html</a></li>
<li><a href="http://blog.csdn.net/liushuijinger/article/details/7586656" target="_blank" rel="noopener">http://blog.csdn.net/liushuijinger/article/details/7586656</a></li>
</ol>

          
          <hr>
          <ul class="pager">
              
              <li class="previous">
                  <a href="/blog/理解垃圾回收机制/" data-toggle="tooltip" data-placement="left"
                     title="理解垃圾回收机制">&larr; Previous Post</a>
              </li>
              
              
              <li class="next">
                  <a href="/blog/大嘴李和童话镇5/" data-toggle="tooltip" data-placement="top"
                     title="大嘴李和童话镇 21 - 25">Next Post&rarr;</a>
              </li>
              
          </ul>
        
  <br>
  

  
  </div>


        
  <div class="hidden-xs col-sm-3 toc-col">
    <div class="toc-wrap">
        Table of Contents
        
          <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-管道"><span class="toc-number">1.</span> <span class="toc-text">1. 管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-特点"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-原型"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-例子"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-FIFO"><span class="toc-number">2.</span> <span class="toc-text">2. FIFO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-特点"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-原型"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-例子"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-消息队列"><span class="toc-number">3.</span> <span class="toc-text">3. 消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-特点"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-原型"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-例子"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-信号量"><span class="toc-number">4.</span> <span class="toc-text">4. 信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-特点"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-原型"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 原型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-共享内存"><span class="toc-number">5.</span> <span class="toc-text">5. 共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-特点"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-原型"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3例子"><span class="toc-number">5.3.</span> <span class="toc-text">5.3例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引用"><span class="toc-number">6.</span> <span class="toc-text">引用</span></a></li></ol>
        
    </div>
  </div>


      </div>
  </div>
</article>

<!-- Footer -->
<!-- footer.ejs -->
<footer>
    <div class="text-center">
      <ul class="list-inline">
          
          
          

          

          
              <li>
                  <a target="_blank" href="https://www.facebook.com/stevenhuanlee">
                      <span class="fa-stack fa-lg">
                          <i class="fa fa-circle fa-stack-2x"></i>
                          <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                      </span>
                  </a>
              </li>
          

          
              <li>
                  <a target="_blank"  href="https://github.com/longaspire">
                      <span class="fa-stack fa-lg">
                          <i class="fa fa-circle fa-stack-2x"></i>
                          <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                      </span>
                  </a>
              </li>
          

          
              <li>
                  <a target="_blank"  href="https://www.linkedin.com/in/lihuancs">
                      <span class="fa-stack fa-lg">
                          <i class="fa fa-circle fa-stack-2x"></i>
                          <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                      </span>
                  </a>
              </li>
          

          
              <li>
                  <a href="mailto:lihuancs@zju.edu.cn" target="_blank">
                      <span class="fa-stack fa-lg">
                          <i class="fa fa-circle fa-stack-2x"></i>
                          <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                      </span>
                  </a>
              </li>
          

      </ul>
     <div class="text-muted copyright">
            &copy;
            
              2018
            
            -
            Huan Li. All rights reserved.
        <br>
          
              Powered by <a target="_blank" href="https://hexo.io">Hexo</a>
          
          
          
          | Hosted by <a target="_blank" href="https://pages.github.com">GitHub Pages</a>
         <p>
            <span id="busuanzi_container_site_pv"><span id="busuanzi_value_site_pv"></span> PV</span> -
            <span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv"></span> UV
        </span>
      </div>
    </div>
</footer>

<!-- Custom Theme JavaScript -->
<script src="/blog/js/main.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



</body>

</html>
